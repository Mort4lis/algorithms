from copy import deepcopy
from random import random
from typing import Any, List


def selection_sort(arr: List[Any]) -> List[Any]:
    """
    Сортировка Выбором.

    Временная сложность: O(n^2)
    Алгоритм: На каждой итерации массива находим минимальный элемент и его индекс.
    Из исходного массива вырываем этот минимальный элемент (по индексу) и вставляем его
    в конец результирующего массива.

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    result = []
    arr_copy = deepcopy(arr)
    for _ in range(len(arr)):
        index = arr_copy.index(min(arr_copy))  # Находим индекс, чей элемент - минимален
        item = arr_copy.pop(index)
        result.append(item)
    return result


def bubble_sort(arr: List[Any]) -> List[Any]:
    """
    Сортировка Пузырьков.

    Временная сложность: O(n^2)
    Алгоритм: Выполняем цикл до тех пор пока есть изменения (перестановки двух элементов местами).
    Берем первые два элемента, проверяем их: если элемент слева больше, чем элемент справа - меняем
    местами, если нет - пропускаем. Берем следующие два элемента и опять проверям их и т.д.

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    result = deepcopy(arr)
    length = len(result)
    has_changes = True

    while has_changes:
        has_changes = False
        for i in range(length - 1):
            if result[i] > result[i + 1]:
                result[i], result[i + 1] = result[i + 1], result[i]
                has_changes = True

    return result


def insertion_sort(arr: List[Any]) -> List[Any]:
    """
    Сортировка Вставками.

    Временная сложность: O(n^2)
    Алгоритм: Начинаем итерироваться по массиву. Берем первый элемент, считаем, что массив
    из одного элемента - отсортирован. Берем второй элемент и находим куда бы его вставить
    в уже отсортированную часть (то есть, пробегаемся задом наперед по отсортированой уже части
    и сравниваем итерируемый элемент с элементом, который хотим вставить. В случае, если итерируемый элемент
    больше, чем тот, который хотим вставить - меняем их местами и т.д). Тоже самое проделываем с третим элементом
    и четвертым. В итоге, после каждой итерации отсортированная часть будет рости (за счет вставок).

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    result = deepcopy(arr)
    for i in range(1, len(result)):
        j = i
        while j > 0 and result[j - 1] >= result[j]:
            result[j], result[j - 1] = result[j - 1], result[j]
            j -= 1
    return result


def quick_sort(arr: List[Any]) -> List[Any]:
    """
    Быстрая сортировка.

    Временная сложность: в лучшем и среднем случае - O(n*log(n)), в худшем случае - O(n^2).
    Алгоритм: данный алгоритм использует подход к решению задачи "разделяй и влавствуй". Данный
    подход является рекурсивным, поэтому необходимо выделить базовый случай и рекурсивный случай.
    В качестве базового случая - выступает ситуация, когда массив, который мы хотим отсортировать,
    состоит из одного элемента, либо он пустой - в таком случае, он является априори отсортированным.
    Задача рекурсивного случая - постоянно делить задачу, чтобы свести ее к простейшемубазовому случаю. Для этого
    мы случайным образом находим "опорный" элемент. Далее, мы выделяем два списка (те элементы, которые меньше
    опорного элемента, и те элементы, которые больше опорного). Тем самым мы поделили задачу на две части. А затем
    вызываем этот же алгоритм (рекурсивно) для списка элементов, меньших опорного и списка элементов,
    больших опорного. Полученные части склеиваем следующим образом:
    quick_sort([массив меньших элементов]) + [опорный элемент] + quick_sort([массив больших элементов]).

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    if len(arr) < 2:
        return arr

    # Берем рандомный элемент в качестве опорного
    index = int(random() * len(arr))
    pivot = arr[index]

    less, greatest = [], []
    for i, item in enumerate(arr):
        if i == index:
            continue
        if item <= pivot:
            less.append(item)
        else:
            greatest.append(item)

    return quick_sort(less) + [pivot] + quick_sort(greatest)


def merge_sort(arr: List[Any]) -> List[Any]:
    """
    Сортировка слиянием.

    Временная сложность: O(n*log(n)) во всех случаях
    Алгоритм: данный алгоритм использует подход к решению задачи "разделяй и влавствуй". Данный
    подход является рекурсивным, поэтому необходимо выделить базовый случай и рекурсивный случай.
    В качестве базового случая - выступает ситуация, когда массив, который мы хотим отсортировать,
    состоит из одного элемента, либо он пустой - в таком случае, он является априори отсортированным.
    Задача рекурсивного случая - постоянно делить задачу, чтобы свести ее к простейшемубазовому случаю.
    Для этого мы каждый раз делим исходных массив на две ровные половинки (плюс/минус). Затем каждую
    половинку делим еще на половинку и т.д., до тех пор пока не сведем задачу к базовому случаю (то есть,
    к одному элементу). Далее, начинается стадия слияния, а именно, пытаемся слить две отсортированных части.
    Пример слияния:
    [3, 5] [2, 4]
    1. 3 сравниваем с 2, 3 > 2, значит 2 ставим в начало результирующего массива ([2])
    2. 3 сравниваем с 4, 4 > 3, значит 3 пушим в результирующий массив ([2, 3])
    3. 5 сравниваем с 4, 5 > 4, значит 4 пушим в результирующий массив ([2, 3, 4])
    4. Второй массив полностью исчерпан, поэтому оставшиемся элементы из первого массива
    пушим в результирующий массив ([2, 3, 4, 5]) - итог: две половинки слились в результирующую
    отсортированную часть.

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    if len(arr) < 2:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    # Слияние отсортированных половинок
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right):
        if left[i] > right[j]:
            result.append(right[j])
            j += 1
        else:
            result.append(left[i])
            i += 1

    if i == len(left):
        result += right[j:]
    elif j == len(right):
        result += left[i:]
    return result
