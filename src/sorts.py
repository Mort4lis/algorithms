from copy import deepcopy
from random import random
from typing import Any, List


def selection_sort(arr: List[Any]) -> List[Any]:
    """
    Сортировка Выбором.

    Временная сложность: O(n^2)
    Алгоритм: На каждой итерации массива находим минимальный элемент и его индекс.
    Из исходного массива вырываем этот минимальный элемент (по индексу) и вставляем его
    в конец результирующего массива.

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    result = []
    arr_copy = deepcopy(arr)
    for _ in range(len(arr)):
        index = arr_copy.index(min(arr_copy))  # Находим индекс, чей элемент - минимален
        item = arr_copy.pop(index)
        result.append(item)
    return result


def bubble_sort(arr: List[Any]) -> List[Any]:
    """
    Сортировка Пузырьков.

    Временная сложность: O(n^2)
    Алгоритм: Выполняем цикл до тех пор пока есть изменения (перестановки двух элементов местами).
    Берем первые два элемента, проверяем их: если элемент слева больше, чем элемент справа - меняем
    местами, если нет - пропускаем. Берем следующие два элемента и опять проверям их и т.д.

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    result = deepcopy(arr)
    length = len(result)
    has_changes = True

    while has_changes:
        has_changes = False
        for i in range(length - 1):
            if result[i] > result[i + 1]:
                result[i], result[i + 1] = result[i + 1], result[i]
                has_changes = True

    return result


def insertion_sort(arr: List[Any]) -> List[Any]:
    """
    Сортировка Вставками.

    Временная сложность: O(n^2)
    Алгоритм: Начинаем итерироваться по массиву. Берем первый элемент, считаем, что массив
    из одного элемента - отсортирован. Берем второй элемент и находим куда бы его вставить
    в уже отсортированную часть (то есть, пробегаемся задом наперед по отсортированой уже части
    и сравниваем итерируемый элемент с элементом, который хотим вставить. В случае, если итерируемый элемент
    больше, чем тот, который хотим вставить - меняем их местами и т.д). Тоже самое проделываем с третим элементом
    и четвертым. В итоге, после каждой итерации отсортированная часть будет рости (за счет вставок).

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    result = deepcopy(arr)
    for i in range(1, len(result)):
        j = i
        while j > 0 and result[j - 1] >= result[j]:
            result[j], result[j - 1] = result[j - 1], result[j]
            j -= 1
    return result


def quick_sort(arr: List[Any]) -> List[Any]:
    """
    Быстрая сортировка.

    Временная сложность: в лучшем и среднем случае - O(n*log(n)), в худшем случае - O(n^2).
    Алгоритм: данный алгоритм использует подход к решению задачи "разделяй и влавствуй". Данный
    подход является рекурсивным, поэтому необходимо выделить базовый случай и рекурсивный случай.
    В качестве базового случая - выступает ситуация, когда массив, который мы хотим отсортировать,
    состоит из одного элемента, либо он пустой - в таком случае, он является априори отсортированным.
    Задача рекурсивного случая - постоянно делить задачу, чтобы свести ее к простейшемубазовому случаю. Для этого
    мы случайным образом находим "опорный" элемент. Далее, мы выделяем два списка (те элементы, которые меньше
    опорного элемента, и те элементы, которые больше опорного). Тем самым мы поделили задачу на две части. А затем
    вызываем этот же алгоритм (рекурсивно) для списка элементов, меньших опорного и списка элементов,
    больших опорного. Полученные части склеиваем следующим образом:
    quick_sort([массив меньших элементов]) + [опорный элемент] + quick_sort([массив больших элементов]).

    :param arr: Исходный массив элементов
    :return: Отсортированный массив элементов
    """
    if len(arr) < 2:
        return arr

    # Берем рандомный элемент в качестве опорного
    index = int(random() * len(arr))
    pivot = arr[index]

    less, greatest = [], []
    for i, item in enumerate(arr):
        if i == index:
            continue
        if item <= pivot:
            less.append(item)
        else:
            greatest.append(item)

    return quick_sort(less) + [pivot] + quick_sort(greatest)
